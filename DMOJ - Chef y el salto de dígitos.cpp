//Chef y el salto de dígitos//Teoría de grafos : Distrakj#include <iostream>#include <algorithm>#include <stdio.h>#include <vector>#include <math.h>#include <set>#include <string>#include <string.h>#include <stdio.h>#include <queue>#define MID (left+right)/2#define MOD 1000000007#define MAX 110#define MARK 2000010#define MAXTREE (MAX << 2)#define LIMIT 100000#define ULL unsigned long long#define LL long long#define ENDL '\n'#define SYMBOL '#'#define REP(i,n) for(int i=0;i<(int)n;++i)#define REP1_N(i,n) for(int i=1;i<=(int)n;++i)#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)#define ALL(c) (c).begin(), (c).end()#define LINE_BLANK cout<<ENDL;#define INF 100000000#define ROW 110#define COLUMN 110using namespace std;string input;int nnodes;struct Node{    int dist;    vector<int> adj;    vector<int> weight;    char digit;};Node graf[MAX];bool mark[MAX];struct pq_entry{    int node, dist;    bool operator <(const pq_entry &a) const{        if (dist != a.dist) return (dist > a.dist);        return (node > a.node);    }};inline void dijkstra(int source){    priority_queue<pq_entry> pq;    pq_entry P;    for (int i=0;i<nnodes;i++){        if (i == source){            graf[i].dist = 0;            P.node = i;            P.dist = 0;            pq.push(P);        }        else graf[i].dist = INF;    }    while (!pq.empty()){        pq_entry curr = pq.top();        pq.pop();        int nod = curr.node;        int dis = curr.dist;        for (int i=0;i<graf[nod].adj.size();i++){            if (!mark[graf[nod].adj[i]]){                int nextNode = graf[nod].adj[i];                if (dis + graf[nod].weight[i] < graf[nextNode].dist){                    graf[nextNode].dist = dis + graf[nod].weight[i];                    P.node = nextNode;                    P.dist = graf[nextNode].dist;                    pq.push(P);                }            }        }        mark[nod] = true;    }}int main(){    //freopen("Input.txt","r",stdin);    //freopen("Output.txt","w",stdout);    cout.setf(ios::fixed,ios::floatfield);    cout.precision(0);	 ios_base::sync_with_stdio(0);    std::cin.tie(0);	 while(cin>>input){		 nnodes=input.size();		 		 REP(i,nnodes){			graf[i].adj.clear();			graf[i].weight.clear();			graf[i].digit=input[i];			graf[i].dist=2*MAX;		 }		 		 for(int i=0;i<nnodes;i++){								if(i+1<nnodes){					graf[i].adj.push_back(i+1);					graf[i].weight.push_back(1);										graf[i+1].adj.push_back(i);					graf[i+1].weight.push_back(1);				}							 for(int j=i+2;j<nnodes;j++){				 if(graf[i].digit==graf[j].digit){						graf[i].adj.push_back(j);						graf[i].weight.push_back(1);												graf[j].adj.push_back(i);						graf[j].weight.push_back(1);				 }			 }			 }		 		 dijkstra(0);		 cout<<graf[nnodes-1].dist<<ENDL;	 }        return 0;}