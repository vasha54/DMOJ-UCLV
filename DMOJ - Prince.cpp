//DMOJ - Prince//Programacion Dinamica: Mochila 0-1#include <iostream>#include <vector>#include <algorithm>#include <stdio.h>#include <math.h>#include <stack>#include <set>#include <queue>#include <string>#include <string.h>#include <map>#include <complex>#include <cmath>#define MID (left+right)/2#define MOD 1000000007#define MAX 2000#define MAX_ROW 510#define MAX_COLUMN MAX_ROW#define MAXTREE (MAX << 2)#define LIMIT 100010000#define ULL unsigned long long#define LL long long#define ENDL '\n'#define SYMBOL '#'#define REP(i,n) for(int i=0;i<(int)n;++i)#define REP1_N(i,n) for(int i=1;i<=(int)n;++i)#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)#define ALL(c) (c).begin(), (c).end()#define LINE_BLANK cout<<ENDL;#define OPERATOR_INC "++"#define OPERATOR_DEC "--"#define MAXELEMENT 260#define MAXCAPACITYKNAPSACK 1010using namespace std;int nelements, capacity, cases, gananciaTotal;int weight[MAXELEMENT], value[MAXELEMENT], sol[MAXCAPACITYKNAPSACK];int knapsack01(){    for(int i=0;i<=capacity;i++)sol[i]=0;    for(int i=0;i<nelements;i++){       for(int j=capacity;j>=1;j--){          if(weight[i]<=j){             int x=sol[j];             int y=sol[j-weight[i]]+value[i];             sol[j] = max(x,y);          }       }    }    return sol[capacity];}int main(){   //freopen ("Input.txt","r",stdin );    //freopen ("Output.txt","w",stdout );   cout.setf (ios::fixed ,ios::floatfield);   cout.precision (2) ;   ios_base::sync_with_stdio(0);   std::cin.tie(0);	   while(cin>>cases){      gananciaTotal=0;      while(cases--){         cin>>nelements>>capacity;         REP(i,nelements)            cin>>weight[i]>>value[i];         gananciaTotal+=knapsack01();      }      cout<<gananciaTotal<<ENDL;   }   	return 0;}