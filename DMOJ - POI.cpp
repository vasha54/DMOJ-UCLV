//DMOJ - POI//Ordenamiento#include <iostream>#include <vector>#include <algorithm>#include <stdio.h>#include <math.h>#include <stack>#include <set>#include <queue>#include <string>#include <string.h>#include <map>#include <complex>#include <cmath>#define MID (left+right)/2#define MOD 1000000007#define MAX 2000#define MAX_ROW 510#define MAX_COLUMN MAX_ROW#define MAXTREE (MAX << 2)#define LIMIT 100010000#define ULL unsigned long long#define LL long long#define ENDL '\n'#define SYMBOL '#'#define REP(i,n) for(int i=0;i<(int)n;++i)#define REP1_N(i,n) for(int i=1;i<=(int)n;++i)#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)#define ALL(c) (c).begin(), (c).end()#define LINE_BLANK cout<<ENDL;#define OPERATOR_INC "++"#define OPERATOR_DEC "--"using namespace std;struct Concursante{  int id;  int points;  vector<int> problems;    Concursante(int _id=0,int _points=0){      id=_id;      points=_points;      problems.clear();  }     bool operator<(Concursante & _a)const{     if(points > _a.points) return true;     else if(points < _a.points) return false;     else if(points == _a.points){         if(problems.size() > _a.problems.size()) return true;         else if(problems.size() < _a.problems.size()) return false;         else if(problems.size() == _a.problems.size()) return (id < _a.id);     }  }};int nconcursantes,ntask,indexConcursante, pointsTask[MAX],answerTask;vector<Concursante> concursantes;ostream & operator<<(ostream & _out, Concursante & _con){   _out<<"{id:"<<_con.id<<" points:"<<_con.points<<" problem:"<<_con.problems.size()<<"}";   return _out;}int main(){   //freopen ("Input.txt","r",stdin );    //freopen ("Output.txt","w",stdout );   cout.setf (ios::fixed ,ios::floatfield);   cout.precision (2) ;   ios_base::sync_with_stdio(0);   std::cin.tie(0);	   while(cin>>nconcursantes>>ntask>>indexConcursante){      fill(pointsTask,pointsTask+ntask,nconcursantes);      REP(i,nconcursantes)         concursantes.push_back(Concursante(i+1,0));            REP(i,nconcursantes){         REP(j,ntask){            cin>>answerTask;            if( answerTask==1){               pointsTask[j]--;               concursantes[i].problems.push_back(j);            }         }      }            REP(i,nconcursantes){         int nproblem=concursantes[i].problems.size();         REP(j,nproblem)            concursantes[i].points+=(pointsTask[concursantes[i].problems[j]]);      }      sort(concursantes.begin(),concursantes.end());            REP(i,nconcursantes)         if(concursantes[i].id==indexConcursante)         cout<<concursantes[i].points<<" "<<i+1<<ENDL;   }   	return 0;}